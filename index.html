<html>

  <head>
    <link rel="stylesheet" type="text/css" href="lib/main.css">
  </head>

  <body>


    <script src="lib/three.js"></script>
    <script src="lib/jquery.min.js"></script>
    <script src="lib/underscore.js"></script>



    <!-- For Lord Helix -->
    <script src="lib/TrackballControls.js"></script>

    <script src="lib/OBJLoader.js" ></script>
    <script src="lib/ShaderLoader.js"></script>
    <script src="lib/Loader.js"></script>

    <script src="lib/GPGPU.js"></script>
    <script src="lib/CreatePositionsTexture.js"></script>

    <script src="lib/AudioController.js"></script>
    <script src="lib/AudioTexture.js"></script>
    <script src="lib/Stream.js"></script>

    <script src="lib/Flow.js"></script>


    <script id="vs-pass" type="x-shader/x-vertex" data-src="shaders/vs-pass.js">
    </script>
    <script id="fs-pass" type="x-shader/x-fragment" data-src="shaders/fs-pass.js">
    </script>
    <script id="vs-render" type="x-shader/x-vertex" data-src="shaders/vs-render.js">
    </script>
    <script id="fs-render" type="x-shader/x-fragment" data-src="shaders/fs-render.js">
    </script>
    <script id="vs-flow" type="x-shader/x-vertex" data-src="shaders/vs-flow.js">
    </script>
    <script id="fs-flow" type="x-shader/x-fragment" data-src="shaders/fs-flow.js">
    </script>

    <script id="vs-ball" type="x-shader/x-vertex" data-src="shaders/vs-ball.js">
    </script>
    <script id="fs-ball" type="x-shader/x-fragment" data-src="shaders/fs-ball.js">
    </script>


    <script>

      var camera, renderer, scene , controls;
      var size;
      
      var vs, fs;

      var geometry, material , light;

      var rt_oPos, rt_pos, rt_out;
      var flowShader;
      var toGeo;
      var fromGeo;

      var loader;

      var vs = {};
      var fs = {};

      var loader = new Loader();

      var audioController = new AudioController();

      var track = new Stream( 'audio/You.mp3' , audioController , false );
      track.play();

      var vertexShaders       = $('script[type="x-shader/x-vertex"]');
      var fragmentShaders     = $('script[type="x-shader/x-fragment"]');

      console.log( vertexShaders );
      console.log( fragmentShaders );
      
      loadShader( 'pass',   vertexShaders[0]    , 'vertex'    );
      loadShader( 'pass',   fragmentShaders[0]  , 'fragment'  );
      loadShader( 'render', vertexShaders[1]    , 'vertex'    );
      loadShader( 'render', fragmentShaders[1]  , 'fragment'  );
      loadShader( 'flow',   vertexShaders[2]    , 'vertex'    );
      loadShader( 'flow',   fragmentShaders[2]  , 'fragment'  );
  
      loadShader( 'ball',   vertexShaders[3]    , 'vertex'    );
      loadShader( 'ball',   fragmentShaders[3]  , 'fragment'  );

      loader.addToLoadBar();

      var mainMaterial =  new THREE.MeshBasicMaterial({
        color:0x000000
      });

      loader.OBJLoader.load( 'lib/LeePerrySmith.obj' , function( object ){
        object.traverse( function ( child ) {
          if ( child instanceof THREE.Mesh ) {
            var geo = new THREE.Geometry();
            var mesh = new THREE.Mesh( child.geometry , mainMaterial );
            mesh.scale.multiplyScalar( 1000 );
            THREE.GeometryUtils.merge( geo , mesh );
            toGeo = geo;       
          }
        } );
        loader.loadBarAdd();
      });

      loader.OBJLoader.load( 'lib/logo.obj' , function( object ){
        object.traverse( function ( child ) {
            if ( child instanceof THREE.Mesh ) {
              var geo = new THREE.Geometry();
              var mesh = new THREE.Mesh( child.geometry , mainMaterial );
              mesh.scale.multiplyScalar( 10 );
              THREE.GeometryUtils.merge( geo , mesh );
              fromGeo = geo;       
            }
        });
        loader.loadBarAdd();
      });



      
      function init(){

        var w = window.innerWidth;
        var h = window.innerHeight;

        camera = new THREE.PerspectiveCamera( 65 , w/h , 1 , 10000 );
        camera.position.x = -500;

        controls = new THREE.TrackballControls( camera );
        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );


        size = 512;


        flow = new Flow( size );

        fromPos = new THREE.Vector3( 1000 , 0 , 0  );
        toPos = new THREE.Vector3( -1000 , 0 , 0  );
        
        fromRot = new THREE.Euler( 0,-Math.PI / 2,0);
        toRot = new THREE.Euler( 0,Math.PI / 2,0);

        flow.fromTexture = flow.createPositionsTexture( fromGeo , fromPos , fromRot ); 
        flow.toTexture = flow.createPositionsTexture( toGeo , toPos , toRot );       
        flow.flowShader.uniforms.t_from.value = flow.fromTexture;
        flow.flowShader.uniforms.t_to.value = flow.toTexture;

        flow.sprite = THREE.ImageUtils.loadTexture( "lib/lensFlare.png" );
        flow.particles.material.uniforms.map.value = flow.fromTexture;
        flow.particles.material.uniforms.sprite.value = flow.sprite;

        flow.texturePassShader.uniforms.texture.value = flow.fromTexture;
        flow.gpgpu.pass( flow.texturePassShader , flow.rt_1 );
        flow.gpgpu.pass( flow.texturePassShader , flow.rt_2 );
        flow.gpgpu.pass( flow.texturePassShader , flow.rt_3 );

        flow.addBalls();
        //flow.
        scene.add( flow.particles );

        document.body.appendChild( renderer.domElement );
        window.addEventListener( 'resize', onResize , false );
        

        animate();

      }

      
      function animate(){

        requestAnimationFrame( animate );
        controls.update();
        flow.update();
        audioController.update();
        renderer.render( scene , camera );
      }

      function onResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function loadShader( title , shader, type) {

          loader.addToLoadBar();
        
          // wrap up the shader for convenience
          var $shader = $(shader);
          
          // request the file over AJAX
          $.ajax({
              url: $shader.data('src'),
              dataType: 'text',
              context: {
                  name: $shader.data('name'),
                  type: type
              },
              complete: function(r){
                console.log( 'hellos' );
                loader.loadBarAdd();
                if( type == 'vertex' ){
                  vs[title] = r.responseText;
                }else{
                  fs[title] = r.responseText;
                }

              }
          });
          
      }
    </script>

  </body>
</html>
