<html>

  <head>
    <link rel="stylesheet" type="text/css" href="lib/main.css">
  </head>

  <body>


    <script src="lib/three.js"></script>
    <script src="lib/jquery.min.js"></script>
    <script src="lib/underscore.js"></script>



    <!-- For Lord Helix -->
    <script src="lib/TrackballControls.js"></script>

    <script src="lib/OBJLoader.js" ></script>
    <script src="lib/ShaderLoader.js"></script>
    <script src="lib/Loader.js"></script>

    <script src="lib/GPGPU.js"></script>
    <script src="lib/CreatePositionsTexture.js"></script>

    <!-- For Lord Helix -->
    <script src = "lib/OBJLoader.js" ></script>

<script id="vs-pass" type="x-shader/x-vertex" data-src="shaders/vs-pass.js">
</script>

<script id="fs-pass" type="x-shader/x-fragment" data-src="shaders/fs-pass.js">
</script>

<script id="vs-render" type="x-shader/x-vertex" data-src="shaders/vs-render.js">
</script>

<script id="fs-render" type="x-shader/x-fragment" data-src="shaders/fs-render.js">
</script>
<script id="vs-flow" type="x-shader/x-vertex" data-src="shaders/vs-flow.js">
</script>
<script id="fs-flow" type="x-shader/x-fragment" data-src="shaders/fs-flow.js">
</script>


    <script>

      var camera, renderer, scene , controls;
      var size;
      
      var vs, fs;

      var geometry, material , light;

      var rt_oPos, rt_pos, rt_out;
      var flowShader;
      var toGeo;
      var fromGeo;

      var loader;

      var vs = {};
      var fs = {};

      var loader = new Loader();

      var vertexShaders       = $('script[type="x-shader/x-vertex"]');
      var fragmentShaders     = $('script[type="x-shader/x-fragment"]');

      console.log( vertexShaders );
      console.log( fragmentShaders );
      
      loadShader( 'pass',   vertexShaders[0]    , 'vertex'    );
      loadShader( 'pass',   fragmentShaders[0]  , 'fragment'  );
      loadShader( 'render', vertexShaders[1]    , 'vertex'    );
      loadShader( 'render', fragmentShaders[1]  , 'fragment'  );
      loadShader( 'flow',   vertexShaders[2]    , 'vertex'    );
      loadShader( 'flow',   fragmentShaders[2]  , 'fragment'  );

      loader.addToLoadBar();
      loader.OBJLoader.load( 'lib/LeePerrySmith.obj' , function( object ){

        object.traverse( function ( child ) {

        console.log('CHECK' );
            if ( child instanceof THREE.Mesh ) {

              var geo = new THREE.Geometry();
              var mesh = new THREE.Mesh( child.geometry , new THREE.MeshNormalMaterial());

              mesh.scale.multiplyScalar( 1000 );
              THREE.GeometryUtils.merge( geo , mesh );
              toGeo = geo;       
              

            }

        } );

        loader.loadBarAdd();
      });

      loader.OBJLoader.load( 'lib/logo.obj' , function( object ){

        object.traverse( function ( child ) {

        console.log('CHECK' );
            if ( child instanceof THREE.Mesh ) {

              var geo = new THREE.Geometry();
              var mesh = new THREE.Mesh( child.geometry , new THREE.MeshNormalMaterial());

              mesh.scale.multiplyScalar( 10 );
              THREE.GeometryUtils.merge( geo , mesh );
              fromGeo = geo;       
              

            }

        } );

        loader.loadBarAdd();
      });



      
      function init(){

        var w = window.innerWidth;
        var h = window.innerHeight;

        camera = new THREE.PerspectiveCamera( 65 , w/h , 1 , 10000 );
        camera.position.z = 1000;

        controls = new THREE.TrackballControls( camera );
        scene = new THREE.Scene();


        size = 512;

        from = new THREE.CubeGeometry( 200, 200, 200 , 2 , 2 , 2 );
        to = new THREE.IcosahedronGeometry( 200 , 0 );

        fromPos = new THREE.Vector3( 1000 , 0 , 0  );
        toPos = new THREE.Vector3( -1000 , 0 , 0  );
        
        fromRot = new THREE.Euler( 0,-Math.PI / 2,0);
        toRot = new THREE.Euler( 0,Math.PI / 2,0);
        
        var fromTexture = createPositionsTexture( fromGeo , size , fromPos , fromRot);
        var toTexture = createPositionsTexture( toGeo  , size , toPos, toRot );

        var blackMat = new THREE.MeshBasicMaterial({
          color:0x000000,
        })

        var g = new THREE.IcosahedronGeometry( 80 , 4 );
        var centerMesh = new THREE.Mesh( g , blackMat);
        //scene.add( centerMesh );

        var fromMesh = new THREE.Mesh( from , blackMat );
        fromMesh.position = fromPos;
        //scene.add( fromMesh );

        var toMesh = new THREE.Mesh( to , blackMat );
        toMesh.position = toPos;
        //scene.add( toMesh );
       
        var particleGeo = new THREE.BufferGeometry();
        console.log( particleGeo );

        var attribute = new Float32Array( size * size * 3 );
		particleGeo.addAttribute( 'position', Float32Array , size*size , 3 );

        console.log( particleGeo );

        var positions = particleGeo.attributes.position.array;

        for ( var i = 0, j = 0, l = positions.length / 3; i < l; i ++, j += 3 ) {

          positions[ j     ] = ( i % size ) / size;
          positions[ j + 1 ] = Math.floor( i / size ) / size;

        }
        
		var texture = THREE.ImageUtils.loadTexture( "lib/lensFlare.png" );
        
        var uniforms = {

          map:{ type:"t" , value:fromTexture },
          size:{ type:"f" , value:size},
          sprite:{type:"t" , value:texture },

        }

        material = new THREE.ShaderMaterial({
          uniforms:uniforms,
          vertexShader: vs.render,
          fragmentShader: fs.render,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        finalParticles = new THREE.ParticleSystem( particleGeo , material );
        scene.add( finalParticles );

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        rt_1 = new THREE.WebGLRenderTarget( size, size, {
          minFilter: THREE.NearestFilter,
          magFilter: THREE.NearestFilter,
          format: THREE.RGBAFormat,
          type:THREE.FloatType,
          stencilBuffer: false
        });

	    rt_2 = rt_1.clone();
	    rt_3 = rt_2.clone();

        /*
          Setting up a pass through shader 
          for textures
        */

        var uniforms = {
          texture:{  type:"t"  , value:null     },
        }
        
        texturePassShader = new THREE.ShaderMaterial({
          uniforms:uniforms,
          vertexShader:vs.pass,
          fragmentShader:fs.pass
        });


        /*
          Setting Up Flow Simulation Shader
        */

        var circlePos = [];

        for( var i = 0; i < 100; i++ ){

          var x = (Math.random() - .5 ) * 1000;
          var y = (Math.random() - .5 ) * 1000;
          var z = (Math.random() - .5 ) * 1000;


          circlePos.push( new THREE.Vector3( x , y , z ) );

        }

        var uniforms = {
          t_oPos:{  type:"t"  , value:rt_oPos     },
          t_pos:{   type:"t"  , value:rt_pos      },
          t_from:{  type:"t"  , value:fromTexture },
          t_to:{    type:"t"  , value:toTexture   },
          circles:{ type:"v3v" , value:circlePos   }
        }


        flowShader = new THREE.ShaderMaterial({

          uniforms:uniforms,
          vertexShader:vs.flow,
          fragmentShader:fs.flow

        });


        gpgpu = new GPGPU( renderer );

        document.body.appendChild( renderer.domElement );
        window.addEventListener( 'resize', onResize , false );
        

        texturePassShader.uniforms.texture.value = fromTexture;
        gpgpu.pass( texturePassShader , rt_1 );
        gpgpu.pass( texturePassShader , rt_2 );
        gpgpu.pass( texturePassShader , rt_3 );


        var debugGeo = new THREE.PlaneGeometry( 100 , 100 );
        debugMesh_1 = new THREE.Mesh( debugGeo , new THREE.MeshBasicMaterial({
          map: rt_1
        }));
        debugMesh_2 = new THREE.Mesh( debugGeo , new THREE.MeshBasicMaterial({
          map: rt_2
        }));
        debugMesh_3 = new THREE.Mesh( debugGeo , new THREE.MeshBasicMaterial({
          map: rt_3
        }));

        debugMesh_1.position.set( -150 , 200 , 0 );
        debugMesh_2.position.set(   0   , 200 , 0 );
        debugMesh_3.position.set(   150 , 200 , 0 );

        //scene.add(debugMesh_1);
        //scene.add(debugMesh_2);
        //scene.add(debugMesh_3);

        counter = 0;

        animate();

      }

      function render(){

        var flipFlop = counter % 3;

        if( flipFlop == 0 ){

          flowShader.uniforms.t_oPos.value = rt_1;
          flowShader.uniforms.t_pos.value = rt_2;
          gpgpu.pass( flowShader , rt_3 );

          finalParticles.material.uniforms.map.value = rt_3;

  
        }else if( flipFlop == 1 ){
          
          flowShader.uniforms.t_oPos.value = rt_2;
          flowShader.uniforms.t_pos.value = rt_3;
          gpgpu.pass( flowShader , rt_1 );

          finalParticles.material.uniforms.map.value = rt_1;


        }else if( flipFlop == 2 ){

          flowShader.uniforms.t_oPos.value = rt_3;
          flowShader.uniforms.t_pos.value = rt_1;
          gpgpu.pass( flowShader , rt_2 );

          finalParticles.material.uniforms.map.value = rt_2;
            
        }

        counter ++;

      }


      function animate(){

        requestAnimationFrame( animate );
        controls.update();
        render();
        renderer.render( scene , camera );
      }

      function onResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function loadShader( title , shader, type) {

          loader.addToLoadBar();
        
          // wrap up the shader for convenience
          var $shader = $(shader);
          
          // request the file over AJAX
          $.ajax({
              url: $shader.data('src'),
              dataType: 'text',
              context: {
                  name: $shader.data('name'),
                  type: type
              },
              complete: function(r){
                console.log( 'hellos' );
                loader.loadBarAdd();
                if( type == 'vertex' ){
                  vs[title] = r.responseText;
                }else{
                  fs[title] = r.responseText;
                }

              }
          });
          
      }
    </script>

  </body>
</html>
